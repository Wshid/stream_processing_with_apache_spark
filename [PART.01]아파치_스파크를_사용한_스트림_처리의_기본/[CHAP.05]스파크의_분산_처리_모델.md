# [CHAP.05] 스파크의 분산 처리 모델
- 분산 처리 시스템으로서의 스파크
  - 임의의 **워크로드**를 실행하기 위해 **컴퓨팅 리소스**의 **가용성**과 **주소 지정성**에 의존

## 5.1. 클러스터 매니저를 활용한 아파치 스파크 실행
- 클러스터에 의존한 일련의 장비들
  - 일반적인 목적을 가지며
  - 스트리밍 어플리케이션의 **runtime binary**와 **실행 스크립트**(provisioning)을 수신해야 함
- 현대적인 클러스터는
  - 자동으로 관리 되며 `multitenancy`상황에서 많은 수의 장비가 포함됨
  - 많은 이해 관계자가 비즈니스 당일 다양한 시간에 **동일한 클러스터**에 액세스하여 사용하기 원한다는 것을 의미
  - 클러스터는 **클러스터 매니저**에 의해 관리
- 클러스터 매니저
  - 다수의 사용자로부터 **이용 요청을 받음**
  - 일부 **리소스에 연결**
  - 일정 기간동안 사용자를 대신하여 **리소스 예약**
  - 사용자가 사용 가능한 여러 리소스에 **사용자 어플리케이션 배치**
  - 사용 가능한 시스템 풀 중에서
    - 사용자 요청의 **최상의 위치 파악**
  - 여러 사람이 동일한 물리적 인프라 공유시,
    - 사용자 어플리케이션을 **안전하게 격리**
- 매니저의 장점을 살리려면
  - 업무의 단편화
  - 최적의 배치
  - 가용성
  - 선점 및 우선순위 지정
- 아파치 스파크는
  - 기존 **클러스터 매니저**를 활용하여 클러스터에 **워크로드**를 분산

### 5.1.1. 클러스터 매니저의 예
- 매니저 목록
  - yarn
    - apache hadoop project에서 태어난 비교적 성숙한 클러스터
  - mesos
    - **리눅스 컨테이너 기술**을 기반으로한 CM
    - 아파치 스파크의 존재 이유였었음
  - k8s
    - **서비스 지향 API**
    - 구글의 실제 업무에서 탄생하여 **CNCF**(Cloud Native Computing Foundation)을 지향
- 아파치 스파크가 **배포판**으로서, 자체의 **클러스터 매니저**를 포함함
  - 이는 스파크가 고유한 **배포 조정자 역할**을 할 수 있음을 의미
- 이후 내용
  - 스파크 자신의 클러스터 매니저와, 이들의 **특별한 목적**이
    - mesos, yarn, k8s 같은 **프로덕션 클러스터 매니저**에 비해
    - 내결함성 또는 멀티테넌시 영역에서 더 적은 책임을 지는 것에 대해 어떤 의미를 가지는지
  - 분산 스트리밍 어플리케이션에서 예상되는 **표준 수준의 전달 보장 방법**
    - 서로 어떻게 다르며, 어떻게 보증 하는지
  - 마이크로배칭이 10년된 **대량 동기화 처리**(BSP) 모델에서 어떻게 탄생했는지
    - 스파크 스트리밍에서 구조적 스트리밍으로 진화하는 경로 구체화

## 5.2. 스파크 자체 클러스터 매니저
- **로컬 클러스터 매니저**
  - 테스트 목적으로 CM(or RM)의 기능을 모방
  - 몇 개의 사용가능한 코어가 잇는 **로컬 시스템**에 의존
  - 스레딩 모델을 사용하여 **분산 시스템 클러스터**의 존재 재현
  - 일반적으로 사용자 노트북에서만 실행
- **독립 실행형 클러스터 매니저**
  - 비교적 간단한 스파크 전용 CM
  - 리소스 할당의 슬라이스 및 **가용성이 제한적**
  - spark executor가 배포되고 시작된 **전체 작업자 노드**를 보유하고, 사용할 수 있음
  - executor가 미리 배치되었을 것으로 예상하며,
    - 그 `.jar`를 **새 장비로 운송하는 것은 그 범위 밖**
  - 특정 수의 executor를 넘겨 받아,
    - 그것에 대한 작업을 실행할 수 있는 능력을 가짐
  - production 배포에는 권장되지 않음
- 스파크는 **스케줄링**하는 대상이 **사용자 프로그램**에서
  - 추출한 연산의 분배 단위인 **태스크**라는 점에서 **태스크 스케줄러**임
- 스파크는 mesos, yarn, k8s를 포함한 CM을 통해
  - 통신하고, 배포하고
  - 경우에 따라 자체 독립형 CM을 허용함
- 이 통신의 목적은 다수의 `executor`를 예약하는 것
  - 이는 스파크가 **동일한 크기의 연산 리소스**를 이해하는 단위로써
  - 가상의 **노드**와 같은 종류의 것
- **예약된 리소스**는 CM이 다음과 같이 제공할 수 있음(3)
  - 프로세스가 리소스 사용량을 측정하지만
    - 기본적으로 서로의 리소스에 액세스하는 것을 막지 못하는 **제한된 프로세스**
    - yarn의 일부 기본적인 사용 사례
  - **컨테이너**(e.g. mesos, k8s)는 리눅스 커널의 `cgroup`와 `namespace`에서 탄생하고
    - `Docker`프로젝트에서 가장 인기 있는 `iteration`으로 알려져 있는 **경량 리소스 예약 기술**
  - **가상 머신**(VM)에 위와 같은 기능 배포 가능
    - 그 자체로 **코어** 및 **메모리** 예약 기능 제공

### 클러스터 작업
- 위 세가지 기법(3)에 수반되는 서로 다른 수준의 **고립**은 의미 있음
- 엔터프라이즈급 운영 클러스터 관리 영역에서
  - `작업 대기열`, `우선순위`, `멀티태넌시` 옵션 및 사전 예방과 같은 개념을 접할 때
  - 이 개념은 `CM`의 영역이므로, spark를 초점에 맞춘 자료에서는 언급되지 않음
- 여러 사람과 공유하는 `cluster`에서 **좋은 시민**이 되려면, cm의 세부 사항을 파악하는 것이 중요
- 많은 팀이 여러 리소스를 놓고 경쟁하는 동안, 적절하게 클러스터를 운영하는 법
  - 이 장에서 소개하는 참고 자료와, 해당 지역의 `DevOps`팀을 살펴보아야 함