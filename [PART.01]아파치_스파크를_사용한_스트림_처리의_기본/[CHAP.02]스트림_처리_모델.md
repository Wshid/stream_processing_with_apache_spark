# [CHAP.02] 스트림 처리 모델
- 스트림 처리의 구성 요소
  - 데이터 소스
  - 스트림 처리 파이프라인
  - 데이터 싱크
- 과거 계산 기록 : bookeeping
  - 상태 기반 스트림 처리 특성화
- 문제 해결
  - **이벤트 도착 순서**와 **적시성**이 일치하지 않으면 어떻게 할 것 인가
  - 타임스탬프 이벤트 스트림과 기본 개념

## 2.1. 소스와 싱크
- 두가지 스트리밍 시스템
  - 구조적 스트리밍
  - 스파크 스트리밍
- 프로그램의 Runtime에 입력된 데이터에 대해서만 작동 가능
  - **다른 시스템으로 전송되는 즉시**, 데이터에 대한 작동 중지
- 데이터 소스
  - 아파치 스파크의 **스트리밍 프레임워크**에서 데이터 스트림 접근 가능
  - 스트림 처리의 맥락에서
    - 스트림으로부터 데이터에 접근하는 것을 **스트림 소비**(consuming the stream)라고 함
  - 이 추상화는 `kafka`, `flume`, `twitter`, `tcp socket`등과 같은
    - 특정 시스템에 연결하려는 **인스턴스의 구현**을 허용하는 인터페이스로 제공
- streaming sink
  - `spark`외부에 데이터 스트림을 쓰는데 사용
- 스트림 처리 시스템 구성
  - `source - process - sink`
- `source`와 `sink`는 **시스템의 경계**를 나타냄
  - 분산 프레임 워크가 컴퓨팅 리소스간에 매우 복잡한 footprinting을 가질 수 있음
    - 예시 : spark가 다른 `spark cluster` 혹은 `kafka`가 사용되는 다른 분산 시스템에 연결 할 수 있음
- 하나의 `sink`는 다운 스트림 프레임워크의 `source`
  - 일반적으로 이 구성을 `pipeline`이라고 함

## 2.2. 서로 정의된 불변의 스트림
- spark의 두 스트림 API는 **FP**의 형식을 따름
- `data stream`에서 작동하는 **변환/집계**는
  - 해당 스트림이 **변경 불가능**하다고 가정하여 선언
- 따라서 **하나의 주어진 스트림에 대해 하나 또는 여러 개의 요소를 변형하는 것은 불가능**
- 대신, 파싱된 데이터 스트림을 얻기 위해
  - 한 스트림의 콘텐츠를 처리하는 방법을 표현하기 위한 **변환**을 사용
- 이는 프로그램의 어느 특정 지점에서도 프로그램에서
  - **명시적**으로 선언한 일련의 **변환** 및 **조작**을 통해
  - 모든 데이터 스트림을 그것의 **입력**으로 추적할 수 있게 함
- spark cluster의 특정 프로세스는
  - **프로그램**과 **입력 데이터**만 사용하여
  - 데이터 스트림의 내용을 **째구성**할 수 있어 계산이 명확, 재현 가능

## 2.3. 변환과 집계
- spark는 `translation`, `aggregation`을 광범위하게 사용
- **변환**은 스트림의 모든 요소에 대해
  - 동일한 방식으로 **자신을 표현하는 계산**을 의미
  - 예시
    - 입력 스트림의 모든 요소를 두 배로 만들어주는
    - **파생 스트림**을 생성하는 것은, **변환**에 해당
- **집계**는
  - 많은 요소와 **현재까지 관찰된 스트림의 모든 요소에 의존**하는 결과를 생성
  - 예시
    - 입력 스트림 중 상위 `5`개의 숫자를 수집
    - 매 10분마다 일부 판독값의 **평균**을 계산
- **변환**은 **좁은 종속성**
  - 출력의 한 요소를 생성하려면, **입력 요소중 하나만 필요한 특성**
- **집계**는 **넓은 종속성**
  - 출력의 한 요소를 생성하려면, **지금까지 발생한 입력 스트림의 많은 요소 관찰**
- 이를 통해 **고차 함수**를 사용하여
  - 결과를 생성하는 기본 함수 표현 가능
- `spark streaming`과 `structured streaming`은
  - 데이터 스트림을 나타내는 **고유한 방법**이 있지만
  - 작동하는 `API`는 본질적으로 비슷함
    - **불변 입력 스트림**에 적용되는 일련의 **변환**형태로 존재하며
    - 적정한 **스트림**또는 **출력 작업**으로 **출력 스트림 생성**

## 2.4. 윈도우 집계
- 여러 장소의 로그를 중앙 집중식으로
- 최근 일정 기간 동안 발생한 **이벤트의 속성**을 살펴보기
- 규칙적이고 **반복적**인 시간 집계의 어플리케이션 => **window**

### 2.4.1. 텀블링 윈도우
- 각 `x` 기간의 그룹화 함수
  - `시간당 최대 및 최소 주변 온도`
  - `15분당 총 에너지 소비량`
- 각 그룹이 **이전 그룹**을 따르고,
  - **겹치지 않는 고정된 기간**의 그룹을 `tumbling windows`라고 함 
- **각 기간별로 독립적**이어야 함

### 2.4.2. 슬라이딩 윈도우
- 집계 기간 자체보다 **더 높은 빈도**로 보고되는 일정 기간의 집계
- **윈도우 길이**와 **빈도의 집계**를 의미
- 시간 간격 `x`에서 `y`빈도로 보고한 **그룹화 함수**와 같이 판독
  - `마지막 날의 평균 주가는 시간단위로 보고되었다`
- **평균 함수**와 **슬라이딩 윈도우**의 조합은
  - 가장 널리 알려진 슬라이딩 윈도우의 형태
  - **이동 평균**(moving average)
- 윈도우 크기가 30s이고, 보고 빈도가 10s인 윈도우
  - 0s, 30s
  - 10s, 40s
  - 20s, 50s
  - ...
- 다른 요소를 그대로 유지하면서,
  - 최신 데이터를 추가
  - 만료된 요소를 제거

## 2.5. 비상태 및 상태 기반 처리
- 구조적 스트리밍은
  - 데이터 스트림을 각 **행**이 요소에 해당하는 **가상 레코드 테이블**로 간주하여 이 논리를 뒷받침함

## 2.6. 상태 기반 스트림
- 스트림을 경우에 따라
  - **요소** 또는 **요소 그룹**의 연속적이고 독립적인 처리에 중점
  - `이벤트 로그에서 오는 경고 메세지`와 같이
    - 휴리스틱 기반으로 일부 요소에서 작업하는 경우
- 완벽하게 유효하나, 스파크와 같은 **고급 분석 시스템**을 필요로 하지 않음
- 종종 컬렉션에서 **특잇값**을 탐지하거나,
  - 이벤트 데이터로부터 **최근의 집계 통계**를 계산하는 것과 같이
  - 전체 스트림에 의존하는 분석을 기반으로 하는 **새로운 요소**에 대한 실시간 반응에 관심

### 상태 크기 제한하기
- 입력 데이터 스트림 크기에 비례하는 양의 **내부 데이터**를 저장하는 것
  - 하지만 이는, 레코드마다 컴퓨팅 시간 사용 및 무한한 메모리 요구사항이 존재
  - 일반적인 실수
- 스트림 처리의 전제는
  - 입력 이벤트 수에 **제한**이 없으며
  - 분산된 스파크 클러스터에서 **사용 가능한 메모리**가 클 수 있지만, 항상 **제한**되어 있음
  - 중간 상태 표현은 **데이터가 관찰**되는 
    - **전역 데이터 스트림**과 관련된 요소들 상에서
    - 동작하는 연산을 표현하는데 유용할 수 있으나,
    - 다소 안전하지 않음
- **중간 데이터**를 보유하기로 선택한 경우
  - `주어진 시간에 저장할 수 있는 양 < 입력으로 발생할 수 있는 데이터양과 관계없이 사용한 메모리`보다
  - 특정 상한에 **엄격하게 제한**되어 있는지 확인해야 함

### 상태 기반 스트림 처리
- stateful stream processing
- 입력 데이터 스트림에서 관찰된 새로운 데이터 요소에서
  - 무언가를 연산하고, 이 연산을 수행하는 데 도움이 되는 **내부 데이터**를 고치는 것을 원칙으로 함
- `이상 탐지`를 시도하는 경우
  - 우리가 모든 새로운 스트림 요소로 **업데이트**하려는 내부 상태는 **머신러닝 모델**이 되지만
  - 수행하려는 계산은 **입력 요소**가 비정상으로 **분류**되어야 하는지 아닌지 말하기 위한 것
- 대량의 컴퓨팅 성능을 활용할 수 있고, 실시간 데이터에 반응하는 새롭고 흥미로운 방법

## 2.7. 예제: 스칼라에서 로컬 상태 기반 연산
- 피보나치 수열 예시
- 상태 기반 스트림
- `0, 1`로 시작하는 수열이며,
  - 두 개의 이전 요소의 합으로 이루어짐
  ```scala
  val ints = Stream.from(0)
  val fibs = (ints.scanLeft((0, 1)){
    case ((previous, current), index) => (current, (previous + current))
  })

  fibs.take(8).print
  fibs.map{ case (x, y) => x}.take(8).print
  ```
- **상태 기반 스트림 처리**는
  - 결과를 얻기 위해 **과거 정보를 모두 찾는 모든 스트림 처리**
  - 다음 요소를 계산하는 과정에서 **일부 상태 정보 유지** 필요
- `scanLeft` 함수의 **재귀 인수**에서 **상태 정보**가 유지되며,
  - 각 요소에 대해 **두 요소**(탐색 결과값과 그 다음 값)의 튜플을 가진 `fibs`를 찾을 수 있음
- 가장 왼쪽의 요소만 유지하기 위해
  - `fibs`리스트에 간단한 변환을 적용하여 처리 가능
- `n`번째 위치에서 값을 얻으려면
  - **스트림**을 딸 ㅏ이동할 때 중간 `(i-1, i)`요소를 유지하면서
  - 모든 `n-1`의 요소를 처리해야 함

### 2.7.1. 스트림 변환으로서 피보나치 수열의 비상태 정의
- **비상태 맵 함수**를 사용하여
  - 각 숫자를 **피보나치 값**으로 변환하는 **스트림 변환**으로 표현
- 예제 : 피보나치 원소들의 비상태 계산
  ```scala
  import scala.math.{pow, sqrt}
  val phi = (sqrt(5)+1)/2

  def fibonacciNumber(x:Int) = ((pow(phi,x) - pow(-phi, -x))/sqrt(5)).toInt

  val integers = Stream.from(0)
  integers.take(10).print

  val fibonacciSequence = integers.map(fibonacciNumber)

  fibonacciSequence.take(8).print
  ```
- `0`부터 시작하는 **정수 스트림**을 사용하여
  - **피보나치 수열**을 **스트림**을 통해 수신한 정수 `n`을 입력으로 받아
  - 피보나치 수열의 `n`번째 요소를 결과적으로 반환
- `Binet formula`라는 **부동소수점 수 공식**을 사용하여
  - 이전 요소를 요구하지 않고, 수열의 `n`번째를 직접 계산
  - 스트림의 상태를 알 필요가 없음

## 2.8. 비상태 또는 상태 기반 스트리밍
- 상태 기반 버전은
  - 결과를 생성하려면, 더 많은 컴퓨팅 리소스가 필요하다
  - 스트림을 통과시키고, 각 단계에서 **중간값**을 유지해야 함
- 비상태 기반 버전은
  - 비록 인위적이나, **간단한 접근 방식** 사용
- 상태 기반 처리에서는
  - 리소스 측면에서 **비용**이 많이들고
  - **실패**에 대한 우려가 존재
  - 연산이 스트림 중간에 실패할경우, 어떻게 할것인지
    - 경험적으로 안전한 선택은 **비상태 기반 옵션**을 선택하는 것이지만
    - 본질적으로 **상태 기반**처리에 대한 질문이 많음
- 스트림 처리 프레임워크는
  - 이러한 **제약 조건**을 처리할 수 있는 기능을 제공하고,
  - 사용자가 비즈니스에 필요한 솔루션을 자유롭게 만들 수있도록 해야 함

## 2.9. 시간의 영향
- 타임 스탬프 메세지에 대한 작업

### 2.9.1. 타임스탬프 이벤트에 대한 연산
- **처리 시간**(processing time)
  - 스트림 처리 시스템이, 데이터 소스에서 **새로운 이벤트를 관찰**하는 시간
  - 전적으로 **처리 실행 시간**에 의해 결정되며, 스트림 요소 내용과는 독립적
- **이벤트 시간**(event time)
  - 이벤트가 실제로 발생한 시간
  - 이벤트를 감지하는 시스템의 기능이 허용하는 경우
    - 일반적으로 **스트림의 메세지 페이로드**로 추가됨
- **타임스탬핑**(timestamping)
  - 메세지 생성 시, **시간 레지스터**를 추가하는 작업
  - 데이터 스트림의 일부

### 2.9.2. 시간 개념의 제공자로서의 타임 스탬프
- 타임 스탬프의 중요성
  - 사용자가 데이터가 **생성된 순간**을 고려하여, 데이터를 추론할 수 있게 함
- 데이터에 대한 **시간 컨텍스트**를 제공
- **이벤트 로그**는 오늘날 분석되고 있는 **데이터 스트림**의 많은 부분 형성
  - 타임스탬프는, 특정 시간에 특정 시스템에서 발생한 일을 이해하는데 도움이 됨
- 프레임워크 사용자는 시스템의 반응성에 영향을 주지 않으면서, 그러한 위험을 보상받기를 원함(일부 이벤트의 지연, 재배열, 손실 등의 위험)
- 두가지 규칙
  - **정확하고 명확하게 표시되고 재배열된 결과**
  - **중간 예상 결과**
- 위 분류는
  - **스트림 처리 시스템**이 데이터 스트림에 의해 전달된 **타임스탬프 이벤트**에 대한 지식을 반영하고
  - **지연된 스트림 요소**의 늦은 도착에 의해 이 뷰가 **완료될 수 있음**의 단서로 이루어짐
- 이 과정은 **event-time processing**에 대한 기초 구성
- 스파크에서 위 기능은 **구조적 스트리밍**으로 제공

### 2.9.3. 이벤트 시간과 처리 시간
- **이벤트 시간**
  - 동일한 소스의 **모든 이벤트**가 전송 지연의 경우에도 **연대순**으로 정렬 가능함
- **처리 시간**
  - 기술 또는 구현 수준에만 관련
  - 처리 시간 스탬프에 결과를 추가하여
    - **중복값**을 처리 시간이 다른 동일한 출력값으로 구분 가능

### 2.9.4. 워터마크를 사용한 컴퓨팅
- **워터마크**는 어떤 순간에도
  - **데이터 스트림**에서 우리가 받아들일 수 있는 **가장 오래된 타임스탬프**를 의미
  - 이보다 오래된 이벤트는 **스트림 처리 결과**에 포함하지 않음
- 스트리밍 엔진은 **늦은 도착 채널**(late arrival channel)에서 보고하는 것과 같은
  - 다른 방법으로 그것들을 처리할 수 있도록 선택 가능 
- 지연된 이벤트를 설명하기 위해
  - 이 **워터마크**는 보통 **이벤트 전달**에서 기대하는 **평균 지연**보다 훨씬 큼
  - 이 워터마크는 `시간이 지남에 따라 단조롭게 증가`하는 유동적인 값
    - **워터마크는 지연적으로 감소하지 않음**
  - 데이터 스트림 진행에서 관찰되는 시간이 경과함에 따라 **지연 허용의 윈도우**를 미끄러져 감
- 워터 마크 개념이 스트림에 대해 적용된 이후(2)
  - **워터마크**보다 오래된 이벤트와 비교하여 결과를 생산하고 있는 경우
    - 지금까지 모든 요소가 관찰되었기 때문에, 출력이 최종적이며, **그보다 오래된 이벤트는 고려하지 않음**
    - 결과는 최종적이며, **새로운 데이터는 그것을 변경할 수 없음**
  - 워터마크 이전의 데이터와 관련하여 출력을 생성하고
    - 워터마크보다 지연된 새로운 요소가 **언제든지 스트림에 도착**하여 결과 변경이 가능
    - **새로운 데이터가 최종 결과를 여전히 변경 가능함**
      - 출력을 잠정적인 것으로 간주할 수 있음
- **임시 결과**를 사용하여
  - 어떤 식으로든 **중간값**을 저장하고,
  - 지연된 이벤트들이 도착함에 따라, 그들을 **계산에 포함시키는 방법**이 필요
  - 약간의 메모리 공간이 필요함
- **이벤트 시간 처리**는 **상태 기반 연산**의 또 다른 형태로써 동일한 **제한**이 적용됨
  - 워터마크를 처리하기 위해 **스트림 프로세서**가 많은 **중간 데이터를 저장**해야 하며
    - `워터마크 길이 * 도착 속도 * 메세지 크기`에 해당하는 상당한 양의 **메모리 소비**가 필요함
  - 또한, **간격**을 구성하는 모든 요소가 있는지 확인하기 위해
    - **워터마크가 만료될 때까지 기다려야 함**
  - 워터마크를 사용하고, 각 간격에 대한 **최종 결과**를 얻기 위해서는
    - **워터마크의 최소 길이만큼 결과를 지연시켜야 함**

#### 주의
- 이벤트 시간 처리를 통해 **워터마크**를 특정 값으로 설정하는 것이 적절하다고 가정
  - 이벤트 시간 처리에 기초한 스트리밍 계산의 결과는
    - 워터마크가 스트림의 메세지가 실제로 **입력 데이터 스트림**에 대한 생성 시간과 도착 순서 사이에 발생하는 지연을 허용할 경우에만 의미가 있음
      ```bash
      # 아래 지연을 허용할 경우에만 의미 있음
      생성 시간 <= 워터마크의 스트림 메세지 <= 도착 시간
      ```
- 너무 **작은 워터마크**는
  - 많은 **이벤트**를 떨어뜨리며, 심각하게 불완전한 결과를 초래
- 너무 **큰 워터마크**는
  - 완료된 것으로 간주하는 결과의 출력을 **너무 오랫동안 지연시키고**
    - 모든 **중간 이벤트**를 보존하기 위해 리소스 부하가 심함
- 따라서, **이벤트 시간 처리**에 적합하고
  - 사용 가능한 컴퓨팅 리소스에도 적합한 **워터마크 선정**이 필요함

## 2.10. 요약
- 스트림 처리 프로그램 모델의 주요 개념
  - 데이터 소스와 싱크
  - 상태 기반 처리
  - 이벤트 시간 처리