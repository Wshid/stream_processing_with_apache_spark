# [CHAP.12] 이벤트 시간 기반 스트림 처리
- **이벤트 시간 처리**(event-time processing)는
  - 이벤트가 생성된 타임라인에서
    - **이벤트 스트림**을 보고
  - 해당 관점에서 **처리 로직**을 적용하는 것을 말함
- 시간이 지남에 따라 이벤트 데이터의 **패턴**을 분석하는데 관심이 있는 경우
  - **이벤트가 생성**될 때 이벤트를 관찰하는 것처럼
  - 이벤트를 처리해야 함
- 이를 위해서는,
  - 이벤트 생성 시 **장치** 또는 **시스템**이
  - 이벤트를 `stamp` 해야 함
  - 일반적인 `timestamp`는 특정 **이벤트 바인딩 시간**을 나타냄
- 이벤트가 처리되는 순서가 아닌
  - **이벤트가 생성된 상대 순서**에 관심


## 12.1. 구조적 스트리밍에서의 이벤트 시간에 대한 이해
- 서버 측면에서 시간의 개념은
  - 주어진 **어플리케이션**을 실행하는 컴퓨터의 **내부 시계**에 의해 결정
- 머신 클러스터에서 실행되는 분산 어플리케이션의 경우
  - **네트워크 시간 프로토콜**(NTP, Network Time Protocol)과 같은
  - **클럭 동기화 및 프로토콜**을 사용하여
    - 모든 클럭을 동일한 시간에 맞추는 것이 필수적
- 컴퓨터 클러스터에서 실행되는 분산 어플리케이션의 여러 부분이
  - **이벤트**의 타임라인 및 **상대적 순서**에 대해 일관된 결정을 내릴 수 있도록 하기 위한 것
- 하지만 `센서 네트워크, 다른 데이터센터, 휴대전화`등과 같은 외부 장치에서 데이터를 가져올 때,
  - 예컨데 시계가 **머신 클러스터**와 일치한다고 보장할 수 없음
  - 시스템 내부 시계가 아닌
    - **생산 시스템**의 관점에서 들어오는 **이벤트**의 타임라인을 해석해야 함
- 이벤트 타임 라인 예시
  - x축을 처리시간
  - y축을 이벤트 타임라인의 내부 표현
  - `처리시간 != 이벤트시간`
- 이벤트가 시스템에 도착하면 **내부 시간** 개념이 진행
  - 첫번째 이벤트 00:08
    - 기계 시점에서 00:07 유입
    - 내부 시계 계산은, 이벤트 타임라인 인식에 영향을 미치지 않음
  - 이벤트 타임라인이 `00:08`로 진행
  - 다음 이벤트 배치인 `00:10, 00:12, 00:18` 도착
    - 이벤트 타임라인은 가장 최대 시간이므로, `00:18`로 결정
  - `00:15`가 유입, 이벤트 타임라인은 `00:18`로 유지
  - `00:11, 00:09` 유입
    - 이 이벤트를 처리해야할지 고민 필요
  - `00:14, 00:25, 00:28` 유입
    - 스트리밍 시계가 최대 `00:28`로 증가
- 일반적으로 **구조적 스트리밍**은
  - **이벤트**에서 타임스탬프로 선언된 필드의
  - **단조 증가 상한**을 유지하여
  - 이벤트 시간으로 처리된 **이벤트의 타임라인**을 유추
- 이 **비선형 타임라인**은
  - 이 장의 **시간 기반 처리 기능**에 사용되는 판결 클럭
- 이벤트 소스의 시간 흐름을 이해하는 **구조적 스트리밍**기능은
  - 이벤트 처리 시간에서 **이벤트 생성**을 분리
- 과거 이벤트 시퀀스를 재생하고
  - 구조적 스트리밍으로 하여금 모든 **이벤트 시간 집계**에 대해 올바른 결과 생성 불가
- 예시로, 몇 분 안에 `일주일 분량의 이벤트를 재생`할 수 있으며
  - 시스템에서 **일주일**과 일치하는 결과를 얻을 수 있음
- 시간이 **컴퓨터 시간에 의해 통제**된다면, 이것은 **불가능**

## 12.2. 이벤트 시간의 사용
- 구조적 스트리밍에서는 **시간 기반 집계**와 **상태 관리**라는 영역에서
  - 이벤트 시간에 대한 기본 지원 기능 활용 가능
- 위 두 경우 모두
  - 첫번째 단계는 구조적 스트리밍에 적합한 형식의 **데이터 필드**를 **타임스탬프**로 이해하는 것
- `Spark SQL`은 `java.sql.Timestamp`를 `Timestamp` 타입으로 지원
  - 다른 기본 유형의 경우, 이벤트 시간 처리에 값을 사용하려면, `Timestamp`로 변환 필요

#### TABLE.12.1. Timestamp 필드 획득하기

>**ts 기본 타입**|**SQL 함수**
>-----|-----
>Long|$"ts".cast(TimestampType)
>yyyy-MM-dd HH:mm:ss|$"ts".cast(TimestampType)
>yyyy-MM-dd HH:mm:ss(대안)|to\_timestamp($"ts")
>사용자 정의 형식의 문자열 예시|to\_timestamp($"ts", "dd-MM-yyyy HH:mm:ss")

## 12.3. 처리 시간
- **이벤트 시간**은 이벤트가 생성된 **타임라인**과 관련이 있음
  - **처리 시간**과 무관
- **처리 시간**은
  - 엔진에 의해 이벤트가 수집될 때의 타임라인
  - 이벤트 스트림을 **처리하는 컴퓨터의 시계를 기반**으로 함
- **이벤트 데이터**에 시간 정보가 포함되지 않은 경우가 있지만
  - 구조적 스트리밍에서 제공하는 기본 시간 기반 기능을 여전히 활용하려 함
- 이럴 경우 **처리 시간**(`processing-time`) 타임스탬프를
  - **이벤트 데이터**에 추가하고
  - 해당 타임스탬프를 **이벤트 시간**으로 활용할 수 있음
- `currnet_timestamp` SQL을 사용하여, 처리 시간 정보 추가하는 예시
  ```scala
  // 처리 시간 Timestamp 추가
  val timeStampEvents = raw.withColumn("timestamp", current_timestamp())
  ```

## 12.4. 워터마크
- 아래 질문에 대응하기 위해 **워터마크** 개념이 **구조적 스트리밍**에 도입됨
  - 얼마나 늦어야, 아주 늦었다라고 판단할지?
  - 전체 집계를 완료하기 전에 얼마나 오랫동안 **부분 집계**를 **유지**할지?
- 워터마크
  - **이벤트**가 너무 늦음을 선언하기 전에
  - 이벤트를 **기다리는 시간**을 결정하는 **임계값**
- 워터마크를 벗어난 것으로 간주되는 이벤트는 **폐기**
- 기본적으로 **내부 시간 표현**에 따라 임계값으로 계산됨
- 워터마크 라인은
  - **이벤트 시간**정보에서 유추된 **이벤트 시간 타임라인**에서 변경된 라인
  - 내부 이벤트 타임라인보다, 이벤트 시간기준 아래쪽에 위치(허용 범위)
  - 워터마크 라인보다 아래에 위치한 이벤트는, `너무 늦음`으로 판단,
    - 이벤트 스트림을 소비하는 계싼에는 고려되지 않음
- `timestamp` 필드를 **워터마크**에 해당하는 시간 임곗값과 연결하여, 워터마크를 선언 
  ```scala
  val timeStampEvents = raw.withColumn("timestamp", $"ts".cast(TimestampType))
                           .withWatermark("timestamp", "5 minutes")
  ```