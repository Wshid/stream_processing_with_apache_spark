# [CHAP.12] 이벤트 시간 기반 스트림 처리
- **이벤트 시간 처리**(event-time processing)는
  - 이벤트가 생성된 타임라인에서
    - **이벤트 스트림**을 보고
  - 해당 관점에서 **처리 로직**을 적용하는 것을 말함
- 시간이 지남에 따라 이벤트 데이터의 **패턴**을 분석하는데 관심이 있는 경우
  - **이벤트가 생성**될 때 이벤트를 관찰하는 것처럼
  - 이벤트를 처리해야 함
- 이를 위해서는,
  - 이벤트 생성 시 **장치** 또는 **시스템**이
  - 이벤트를 `stamp` 해야 함
  - 일반적인 `timestamp`는 특정 **이벤트 바인딩 시간**을 나타냄
- 이벤트가 처리되는 순서가 아닌
  - **이벤트가 생성된 상대 순서**에 관심


## 12.1. 구조적 스트리밍에서의 이벤트 시간에 대한 이해
- 서버 측면에서 시간의 개념은
  - 주어진 **어플리케이션**을 실행하는 컴퓨터의 **내부 시계**에 의해 결정
- 머신 클러스터에서 실행되는 분산 어플리케이션의 경우
  - **네트워크 시간 프로토콜**(NTP, Network Time Protocol)과 같은
  - **클럭 동기화 및 프로토콜**을 사용하여
    - 모든 클럭을 동일한 시간에 맞추는 것이 필수적
- 컴퓨터 클러스터에서 실행되는 분산 어플리케이션의 여러 부분이
  - **이벤트**의 타임라인 및 **상대적 순서**에 대해 일관된 결정을 내릴 수 있도록 하기 위한 것
- 하지만 `센서 네트워크, 다른 데이터센터, 휴대전화`등과 같은 외부 장치에서 데이터를 가져올 때,
  - 예컨데 시계가 **머신 클러스터**와 일치한다고 보장할 수 없음
  - 시스템 내부 시계가 아닌
    - **생산 시스템**의 관점에서 들어오는 **이벤트**의 타임라인을 해석해야 함
- 이벤트 타임 라인 예시
  - x축을 처리시간
  - y축을 이벤트 타임라인의 내부 표현
  - `처리시간 != 이벤트시간`
- 이벤트가 시스템에 도착하면 **내부 시간** 개념이 진행
  - 첫번째 이벤트 00:08
    - 기계 시점에서 00:07 유입
    - 내부 시계 계산은, 이벤트 타임라인 인식에 영향을 미치지 않음
  - 이벤트 타임라인이 `00:08`로 진행
  - 다음 이벤트 배치인 `00:10, 00:12, 00:18` 도착
    - 이벤트 타임라인은 가장 최대 시간이므로, `00:18`로 결정
  - `00:15`가 유입, 이벤트 타임라인은 `00:18`로 유지
  - `00:11, 00:09` 유입
    - 이 이벤트를 처리해야할지 고민 필요
  - `00:14, 00:25, 00:28` 유입
    - 스트리밍 시계가 최대 `00:28`로 증가
- 일반적으로 **구조적 스트리밍**은
  - **이벤트**에서 타임스탬프로 선언된 필드의
  - **단조 증가 상한**을 유지하여
  - 이벤트 시간으로 처리된 **이벤트의 타임라인**을 유추
- 이 **비선형 타임라인**은
  - 이 장의 **시간 기반 처리 기능**에 사용되는 판결 클럭
- 이벤트 소스의 시간 흐름을 이해하는 **구조적 스트리밍**기능은
  - 이벤트 처리 시간에서 **이벤트 생성**을 분리
- 과거 이벤트 시퀀스를 재생하고
  - 구조적 스트리밍으로 하여금 모든 **이벤트 시간 집계**에 대해 올바른 결과 생성 불가
- 예시로, 몇 분 안에 `일주일 분량의 이벤트를 재생`할 수 있으며
  - 시스템에서 **일주일**과 일치하는 결과를 얻을 수 있음
- 시간이 **컴퓨터 시간에 의해 통제**된다면, 이것은 **불가능**