# [CHAP.13] 고급 상태 기반 작업
- CHAP.08 - 구조적 스트리밍에서의 집계
- CHAP.12 - 이벤트 시간 처리
- 단, **기본 제공 모델**에서 직접 지원하지 않는 **사용자 지정 집계 기준**을 충족해야하는 경우 존재
  - 이 상황을 해결하기 위해 **고급 상태 기반 작업**을 수행하는 방법
- **구조적 스트리밍**은 **임의의 상태 기반 처리**를 구현하는 API 제공
  - 이 `API`는 `mapGroupsWithState` 및 `flatMapGroupsWithState`의 두가지 작업으로 표현
  - 두 작업 모두 **상태**의 **사용자 정의**를 만들고
  - 시간이 지남에 따라 새로운 데이터가 들어올 때,
    - 이 상태가 **어떻게 발전하는지**에 대한 규칙을 설정
    - **만료시기** 결정
  - **상태 정의**를 `들어오는 데이터`와 결합하여 **결과를 산출하는 방법** 제공
- `mapGroupsWithState` 및 `flaptMapGroupsWithState`의 차이점
  - `mapGroupsWithState`: 각 처리된 그룹에 대해 **단일 결과** 생성
  - `flaptMapGroupsWithState`: `0개 이상`의 결과 생성
  - 의미론적으로
    - `새로운 데이터`가 항상 `새로운 상태`로 귀결 => `mapGroupsWithState` 사용
    - `다른 모든 경우` => `flatMapGroupsWithState` 사용
- 내부적으로 **구조적 스트리밍**은
  - **운영 간의 상태 관리**를 담당하며
  - 시간이 지남에 따라 **스트리밍 프로세스**동안 **가용성**과 **내결함성 보존**을 보장

## 13.1. 예제: 차량 유지 보수 관리
- 각 차량은 지리적 `위치`, `연료 레벨`, `가속도`, `베어링`, `엔진 온도` 등과 같은 많은 **작동 파라미터**를
  - 정기적으로 보고
- 이 원격 측정 데이터를 활용하여
  - 비즈니스 운영 및 재무 측면 관리에 도움이 되는 App 개발
- 여행의 개념을 `출발부터 정지`까지의 **주행 도로 구간**으로 가정
  - 개별적으로 **여행**의 개념 => **연료 효율**을 계산하거나 **가상 경계 협정 준수**를 감시
  - 그룹으로 분석하면
    - `교통 패턴`, `교통 핫스팟`을 드러낼 수 있음
  - 다른 센서 정보와 결합시, `도로 상태` 보고 가능
- 스트림 처리 관점에서는
  - 여행을 `차량이 움직이기 시작할 때 열리고, 정지할 때 닫히는 임의의 윈도우`로 볼 수 있음
- 순전히 **시간**에 근거하는 것이 아닌
  - 임의의 조건에 근거한 **강력한 상태 정의**가 필요
- 예제에서 이 조건은 **차량이 주행중**임을 의미

## 13.2. 상태 작동을 통한 그룹의 이해
- 임의 작동 상태인 `mapGroupsWithState` 및 `flatMapGroupWithState`는
  - `scala` 또는 `java` binding을 사용하여 **입력한 데이터셋 API**에서만 동작
- 처리하고 있는 **데이터**와, **상태 기반 변환**을 요건을 바탕으로
  - 세 가지 유형 정의를 제공해야 함
  - 전형적으로 `case class`또는 `java Bean`으로 인코딩
- **세 가지 유형**
  - 입력 이벤트(I)
  - 유지할 임의의 상태(S)
  - 출력(O) - 이 타입은 적절한 경우 **상태 표현**과 동일할 수 있음
- 이러한 모든 타입은 `Spark SQL`로 **인코딩**할 수 있어야 함
  ```scala
  import spark.implicits._
  ```
  - 모든 **기본 타입**, **튜블** 그리고 `case class`에 충분
- 이러한 타입을 사용할 경우, **사용자 지정 상태 처리 논리**를 구현하는 **상태 변환 함수**를 공식화 가능
  - `mapGroupsWithState`에서는 이 함수가 **단일 필수 값**을 리턴할 것을 요청
    ```scala
    def mappingFunction(key: K, values: Iterator[I], state: GroupState[S]): O
    ```
  - `flatMapGroupsWithState`에서는 이 함수가 `0개 이상의 요소를 포함`할 수 있는 `Iterator`를 리턴
    ```scala
    def flatMappingFunction(
        key: K, values: Iterator[I], state: GroupState[S]): Iterator[O]
    ```
    - `GroupState[S]`는 **구조적 스트리밍**에서 제공하는 **래퍼**이며
      - 내부적으로 **실행 전반**에 걸쳐 상태 `S`를 관리하는데 사용
    - 이 함수내에서, `GroupState`는
      - 상태에 대한 `mutation` 액세스와 **시간 초과**를 확인 및 설정하는 기능 제공

#### Caution: mappingFunction/FlatMappingFunction의 구현은 직렬화 가능해야 함
- Runime에 이 함수는 **자바 직렬화**를 사용하여 클러스터의 **Executor**에 배포
- 이 요구사항은 **카운터**나 기타 **뮤테이블 변수**(mutable variable)와 같은 **국소 상태**를
  - **함수에 본문에 포함시키지 않아야 한다**는 결과를 가지고 있음
- 모든 **관리 상태**를 **상태 표시 클래스**에 **캡슐화**해야 함